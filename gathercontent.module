<?php

/**
 * @file
 * Main module file for GatherContent module.
 */

use Drupal\Component\Render\PlainTextOutput;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\EntityTypeInterface;
use Drupal\Core\Field\BaseFieldDefinition;
use Drupal\Core\Language\Language;
use Drupal\Core\Language\LanguageInterface;
use Drupal\field\Entity\FieldConfig;
use Drupal\gathercontent\Entity\Mapping;
use Drupal\gathercontent\Entity\OperationItem;
use Drupal\gathercontent\Event\GatherContentEvents;
use Drupal\gathercontent\Event\PostImportEvent;
use Drupal\gathercontent\Event\PostNodeSaveEvent;
use Drupal\gathercontent\Event\PreNodeSaveEvent;
use Drupal\menu_link_content\Entity\MenuLinkContent;
use Drupal\node\Entity\Node;
use Drupal\node\NodeInterface;
use Drupal\taxonomy\Entity\Term;
use Symfony\Component\HttpFoundation\RedirectResponse;

/**
 * Implements hook_entity_base_field_info().
 *
 * Add a 'GC mapping ID' and 'GC ID fields' base field to all node types.
 *
 * {@inheritdoc}
 */
function gathercontent_entity_base_field_info(EntityTypeInterface $entity_type) {
  $fields = [];
  if ($entity_type->id() === 'node') {
    $fields['gc_mapping_id'] = $storage_definition = BaseFieldDefinition::create('integer')
      ->setLabel(t('GC mapping ID'))
      ->setDescription(t('The ID of GatherContent mapping.'))
      ->setReadOnly(TRUE);
    $fields['gc_id'] = $storage_definition = BaseFieldDefinition::create('integer')
      ->setLabel(t('GC ID'))
      ->setDescription(t('The ID of GatherContent content.'))
      ->setReadOnly(TRUE);
  }
  if ($entity_type->id() === 'file') {
    $fields['gc_id'] = $storage_definition = BaseFieldDefinition::create('integer')
      ->setLabel(t('GC ID'))
      ->setDescription(t('The ID of GatherContent content.'))
      ->setReadOnly(TRUE);
  }

  return $fields;
}

/**
 * Create menu link if requested.
 *
 * @param int $nid
 *   ID of \Drupal\node\NodeInterface object.
 * @param string $title
 *   Title for menu link.
 * @param string $plid
 *   Parent menu link ID, null if we don't want to create menu link.
 * @param null|string $lang
 *   Langcode for menu link.
 * @param null|int $original_link_id
 *   ID of menu link item in default language.
 */
function gc_create_menu_link($nid, $title, $plid, $lang = NULL, &$original_link_id = NULL) {
  $weight = 1;
  if (!empty($plid)) {
    if (is_null($lang)) {
      // Single language node.
      list($menu_name, $mlid) = explode(':', $plid);
      // Get parent menu link ID.
      if ($menu_name === 'node') {
        _gc_get_menu_by_gc_id($mlid, $menu_name);
      }
      $link = [
        'link' => ['uri' => 'entity:node/' . $nid],
        'title' => $title,
        'menu_name' => $menu_name,
        'parent' => $mlid,
      ];
      MenuLinkContent::create($link)->set('weight', $weight)->save();
    }
    elseif (\Drupal::moduleHandler()->moduleExists('content_translation')
      && \Drupal::service('content_translation.manager')
        ->isEnabled('menu_link_content')
    ) {
      if (!is_null($lang) && is_null($original_link_id)) {
        // Multi language node - first language.
        list($menu_name, $mlid) = explode(':', $plid);
        // Get parent menu link ID.
        if ($menu_name === 'node') {
          _gc_get_menu_by_gc_id($mlid, $menu_name, $lang);
        }
        $link = [
          'link' => ['uri' => 'entity:node/' . $nid],
          'title' => $title,
          'menu_name' => $menu_name,
          'parent' => $mlid,
          'langcode' => $lang,
        ];
        $menu_link = MenuLinkContent::create($link);
        $menu_link->set('weight', $weight);
        $menu_link->save();

        $original_link_id = $menu_link->id();
      }
      elseif (!is_null($lang) && !is_null($original_link_id)) {
        // Multi language node - other language.
        list($menu_name, $mlid) = explode(':', $plid);
        if ($menu_name === 'node') {
          _gc_get_menu_by_gc_id($mlid, $menu_name, $lang);
        }
        $link = [
          'link' => ['uri' => 'entity:node/' . $nid],
          'title' => $title,
          'menu_name' => $menu_name,
          'parent' => $mlid,
          'langcode' => $lang,
        ];

        // Load parent item.
        $original_item = MenuLinkContent::load($original_link_id);
        $original_item->addTranslation($lang, $link);
        $original_item->save();
      }
    }
  }
}

/**
 * Load menu name and menu link id for other languages by node ID.
 *
 * @param int $mlid
 *   Menu link ID.
 * @param string $menu_name
 *   Name of the menu.
 * @param string|null $language
 *   Langcode if menu link item will be translatable.
 */
function _gc_get_menu_by_gc_id(&$mlid, &$menu_name, $language = NULL) {
  // Load node by gc_id.
  $node_ids = \Drupal::entityQuery('node')
    ->condition('gc_id', $mlid)
    ->execute();
  if (!empty($node_ids)) {
    // Load menu_link by node_id.
    $node = reset($node_ids);
    $ml_result = \Drupal::entityQuery('menu_link_content')
      ->condition('link.uri', 'entity:node/' . $node);
    if (!is_null($language)) {
      $ml_result->condition('langcode', $language);
    }
    $mls = $ml_result->execute();
    if (!empty($mls)) {
      $ml = reset($mls);
      $ml_object = MenuLinkContent::load($ml);
      $menu_name = $ml_object->getMenuName();
      $mlid = 'menu_link_content:' . $ml_object->uuid();
    }
  }
}

/**
 * Batch operation callback.
 *
 * We are doing real import thing here.
 *
 * @param int $gc_id
 *   ID of content we want to import.
 * @param int $status_id
 *   ID of status, if 0 then we don't want to change status.
 * @param string $operation_uuid
 *   UUID of operation.
 * @param bool $drupal_status
 *   Status on node in Drupal - published/unpublished.
 * @param string $node_update_method
 *   Name of the node update method.
 * @param int|null $parent_menu_item
 *   ID of mlid.
 * @param array $context
 *   Context of operation.
 */
function gathercontent_import_process($gc_id, $status_id, $operation_uuid, $drupal_status, $node_update_method, $parent_menu_item = NULL, &$context = []) {
  $importer = new \Drupal\gathercontent\Importer();
  if (($nid = $importer->_gc_fetcher($gc_id, $operation_uuid, $drupal_status, $node_update_method, $status_id, $parent_menu_item)) !== FALSE) {
    if ($status_id != 0) {
      // Change status.
      /** @var \Drupal\gathercontent\DrupalGatherContentClient $client */
      $client = \Drupal::service('gathercontent.client');
      $client->itemChooseStatusPost($gc_id, $status_id);
    }
  };
  $context['results']['uuid'] = $operation_uuid;
}

/**
 * Finished callback.
 *
 * {@inheritdoc}
 */
function gathercontent_import_finished($success, $results, $operations) {
  if ($success) {
    // Select all items with uuid.
    $result = \Drupal::entityQuery('gathercontent_operation_item')
      ->condition('operation_uuid', $results['uuid'])
      ->execute();
    if (!empty($result)) {
      $operation_items = OperationItem::loadMultiple($result);
      $success_counter = 0;
      $nids = ['success' => [], 'failed' => []];
      foreach ($operation_items as $operation_item) {
        /** @var \Drupal\gathercontent\Entity\OperationItem $operation_item */
        if ($operation_item->getStatus() === 'Success') {
          $success_counter++;
          $nids['success'][] = [
            'nid' => $operation_item->get('nid')->value,
            'gc_id' => $operation_item->get('gc_id')->value,
          ];
        }
        else {
          $nids['failed'][] = [
            'nid' => $operation_item->get('nid')->value,
            'gc_id' => $operation_item->get('gc_id')->value,
          ];
        }
      }
      $unsuccessful = count($result) - $success_counter;
      drupal_set_message(\Drupal::translation()
        ->formatPlural($success_counter, '1 item was imported successfully.', '@count items were imported successfully.'));
      if ($unsuccessful > 0) {
        drupal_set_message(\Drupal::translation()
          ->formatPlural($unsuccessful, '1 item was not imported. Check errors below.', '@count items were not imported. Check errors below.'), 'error');
      }
      \Drupal::service('event_dispatcher')
        ->dispatch(GatherContentEvents::POST_IMPORT, new PostImportEvent($nids['success'], $nids['failed'], $results['uuid']));
    }
    return new RedirectResponse('admin/config/gathercontent/import/result/' . $results['uuid']);
  }
  else {
    $error_operation = reset($operations);
    drupal_set_message(
      t('An error occurred while processing @operation with arguments : @args',
        [
          '@operation' => $error_operation[0],
          '@args' => print_r($error_operation[0], TRUE),
        ]
      ),
      'error'
    );
  }
  return TRUE;
}

/**
 * Batch operation callback.
 *
 * We are doing real update thing here.
 *
 * @param int $gc_id
 *   ID of content we want to import.
 * @param string $operation_uuid
 *   UUID of operation.
 * @param string $node_update_method
 *   Name of the node update method.
 * @param array $context
 *   Context of operation.
 */
function gathercontent_update_process($gc_id, $operation_uuid, $node_update_method, array &$context) {
  (new \Drupal\gathercontent\Importer())->_gc_fetcher($gc_id, $operation_uuid, 0, $node_update_method);
  $context['results']['uuid'] = $operation_uuid;
}

/**
 * Finished callback.
 *
 * @inheritdoc
 */
function gathercontent_update_finished($success, $results, $operations) {
  if ($success) {
    // Select all items with uuid.
    $result = \Drupal::entityQuery('gathercontent_operation_item')
      ->condition('operation_uuid', $results['uuid'])
      ->execute();
    if (!empty($result)) {
      $operation_items = OperationItem::loadMultiple($result);
      $success_counter = 0;
      $nids = ['success' => [], 'failed' => []];
      foreach ($operation_items as $operation_item) {
        /** @var \Drupal\gathercontent\Entity\OperationItem $operation_item */
        if ($operation_item->getStatus() === 'Success') {
          $success_counter++;
          $nids['success'][] = [
            'nid' => $operation_item->get('nid')->value,
            'gc_id' => $operation_item->get('gc_id')->value,
          ];
        }
        else {
          $nids['failed'][] = [
            'nid' => $operation_item->get('nid')->value,
            'gc_id' => $operation_item->get('gc_id')->value,
          ];
        }
      }
      $unsuccessful = count($result) - $success_counter;
      drupal_set_message(\Drupal::translation()
        ->formatPlural($success_counter, '1 item was imported successfully.', '@count items were imported successfully.'));
      if ($unsuccessful > 0) {
        drupal_set_message(\Drupal::translation()
          ->formatPlural($unsuccessful, '1 item was not imported. Check errors below.', '@count items were not imported. Check errors below.'), 'error');
      }

      \Drupal::service('event_dispatcher')
        ->dispatch(GatherContentEvents::POST_IMPORT, new PostImportEvent($nids['success'], $nids['failed'], $results['uuid']));
    }
    return new RedirectResponse('admin/config/gathercontent/update/result/' . $results['uuid']);
  }
  else {
    $error_operation = reset($operations);
    drupal_set_message(
      t('An error occurred while processing @operation with arguments : @args',
        [
          '@operation' => $error_operation[0],
          '@args' => print_r($error_operation[0], TRUE),
        ]
      ),
      'error'
    );
  }
  return TRUE;
}

/**
 * Check if content type has any metatag fields.
 *
 * @param string $content_type
 *   Machine name of content type.
 *
 * @return bool
 *   TRUE if metatag field exists.
 */
function check_metatag($content_type) {
  $instances = \Drupal::service('entity_field.manager')
    ->getFieldDefinitions('node', $content_type);
  foreach ($instances as $name => $instance) {
    /** @var \Drupal\Core\Field\FieldDefinitionInterface $instance */
    if ($instance->getType() === 'metatag') {
      return TRUE;
    }
  }
  return FALSE;
}

/**
 * Get list of metatag fields.
 *
 * @param string $content_type
 *   Machine name of content type.
 *
 * @return array
 *   Array of metatag fields.
 */
function get_metatag_fields($content_type) {
  $instances = \Drupal::service('entity_field.manager')
    ->getFieldDefinitions('node', $content_type);
  $fields = [];
  foreach ($instances as $name => $instance) {
    /** @var \Drupal\Core\Field\FieldDefinitionInterface $instance */
    if ($instance->getType() === 'metatag') {
      $fields[] = $instance->getName();
    }
  }
  return $fields;
}
